# -*- coding: utf-8 -*-
"""DNA Sequence Classifier

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aNKvFIfKMyga-_kQjdI6fle-edg6rYKX

### DNA Sequencing Using Machine Learning
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing Libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline

"""
Importing Data (Human, Dog, Chimpanze)"""

#importing Dataset
human_data = pd.read_table('human_data.txt')
dog_data = pd.read_table('dog_data.txt')
chimp_data = pd.read_table('chimp_data.txt')
chimp_data.head()

"""### Gene sequence function groups."""

from IPython.display import Image
Image('download.png')

"""## K-mer counting

<p>A challenge that remains is that none of these above methods results in vectors of uniform length, and that is a requirement for feeding data to a classification or regression algorithm. So with the above methods you have to resort to things like truncating sequences or padding with "n" or "0" to get vectors of uniform length.</p>

<p>DNA and protein sequences can be viewed metaphorically as the language of life. The language encodes instructions as well as function for the molecules that are found in all life forms. The sequence language analogy continues with the genome as the book, subsequences (genes and gene families) are sentences and chapters, k-mers and peptides (motifs) are words, and nucleotide bases and amino acids are the alphabet. Since the analogy seems so apt, it stands to reason that the amazing work done in the natural language processing field should also apply to the natural language of DNA and protein sequences.</p>

<p>In genomics, we refer to these types of manipulations as "k-mer counting", or counting the occurances of each possible k-mer sequence. There are specialized tools for this, but the Python natural language processing tools make it supe easy.</center>
"""

# Function to convert Sequence strings into K-mer words default size = 6
def getKmer(seq,size=6):
    return [seq[x:x+size].lower() for x in range(len(seq)-size+1)]

human_data['words'] = human_data.apply(lambda x: getKmer(x['sequence']),axis = 1)
human_data = human_data.drop('sequence',axis=1)
dog_data['words'] = dog_data.apply(lambda x: getKmer(x['sequence']),axis = 1)
dog_data = dog_data.drop('sequence',axis=1)
chimp_data['words'] = chimp_data.apply(lambda x: getKmer(x['sequence']),axis = 1)
chimp_data = chimp_data.drop('sequence',axis=1)

human_data

"""### Converting List of k-mer into strings


"""

#Since we are going to use scikit-learn natural language processing tools to do the k-mer counting, 
#we need to now convert the lists of k-mers for each gene into string sentences of words that the 
#count vectorizer can use. We can also make a y variable to hold the class labels

human_text = list(human_data['words'])
for i in range(len(human_text)):
    human_text[i]  = ' '.join(human_text[i])
y_human = human_data.iloc[:,0].values

human_text[0]

y_human

# Similarly Doing for Chimpanzee and Dog
chimp_text = list(chimp_data['words'])
for i in range(len(chimp_text)):
    chimp_text[i]  = ' '.join(chimp_text[i])
y_chimp = chimp_data.iloc[:,0].values


dog_text = list(dog_data['words'])
for i in range(len(dog_text)):
    dog_text[i]  = ' '.join(dog_text[i])
y_dog = dog_data.iloc[:,0].values

# Applying Bag of words using countvectorizer using NLP
from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(ngram_range=(4,4))
X_human = cv.fit_transform(human_text)
X_dog = cv.transform(dog_text)
X_chimp = cv.transform(chimp_text)

print(X_human.shape)

human_data['class'].value_counts().sort_index().plot.bar()

# Splitting test and train data 

from sklearn.model_selection import train_test_split
X_human_train,X_human_test,y_human_train,y_human_test = train_test_split(X_human,y_human,test_size=0.2,random_state = 42)    
X_dog_train,X_dog_test,y_dog_train,y_dog_test = train_test_split(X_dog,y_dog,test_size=0.2,random_state = 42)    
X_chimp_train,X_chimp_test,y_chimp_train,y_chimp_test = train_test_split(X_chimp,y_chimp,test_size=0.2,random_state = 42)

X_human_train.shape

"""##Multinomial Naive Bayes"""

from sklearn.naive_bayes import MultinomialNB
clf_human = MultinomialNB(alpha = 0.1)
clf_dog = MultinomialNB(alpha = 0.1)
clf_chimp = MultinomialNB(alpha = 0.1)

clf_human.fit(X_human_train,y_human_train)
clf_dog.fit(X_dog_train,y_dog_train)
clf_chimp.fit(X_chimp_train,y_chimp_train)

y_human_pred = clf_human.predict(X_human_test)
y_dog_pred = clf_dog.predict(X_dog_test)
y_chimp_pred = clf_chimp.predict(X_chimp_test)

"""## Analysing Results"""

from sklearn.metrics import accuracy_score,f1_score,precision_score,recall_score

def get_metric(y_test,y_pred):
    accuracy  = accuracy_score(y_test,y_pred)
    precision  = precision_score(y_test,y_pred,average = 'weighted')
    recall  = recall_score(y_test,y_pred,average = 'weighted')
    f1 = f1_score(y_test,y_pred,average = 'weighted')

    return accuracy,precision,recall,f1

print('Confusion Matrix Human\n')
print(pd.crosstab(pd.Series(y_human_test,name='Actual'),pd.Series(y_human_pred,name='Predicted')))
accuracy_human, precision_human, recall_human, f1_human = get_metric(y_human_test,y_human_pred)
print('Accuracy = %.3f \n Precision = %.3f \n recall = %.3f \n F1 = %.3f'%(accuracy_human,precision_human,recall_human,f1_human))

print('---------------------------------------------------------------------------------------------------------------------------------------')



print('Confusion Matrix Dog\n')
print(pd.crosstab(pd.Series(y_dog_test,name='Actual'),pd.Series(y_dog_pred,name='Predicted')))
accuracy_dog, precision_dog, recall_dog, f1_dog = get_metric(y_dog_test,y_dog_pred)
print('Accuracy = %.3f \n Precision = %.3f \n recall = %.3f \n F1 = %.3f'%(accuracy_dog,precision_dog,recall_dog,f1_dog))


print('---------------------------------------------------------------------------------------------------------------------------------------')

print('Confusion Matrix Chimp\n')
print(pd.crosstab(pd.Series(y_chimp_test,name='Actual'),pd.Series(y_chimp_pred,name='Predicted')))
accuracy_chimp, precision_chimp, recall_chimp, f1_chimp = get_metric(y_chimp_test,y_chimp_pred)
print('Accuracy = %.3f \n Precision = %.3f \n recall = %.3f \n F1 = %.3f'%(accuracy_chimp,precision_chimp,recall_chimp,f1_chimp))

